---
/**
 * 3D Neural Network Sphere Component
 * Uses Three.js to render an interactive 3D sphere with network nodes
 */
---

<div class="neural-sphere-wrapper" data-sphere-id={Math.random().toString(36).substr(2, 9)}></div>

<style>
  .neural-sphere-wrapper {
    width: 100%;
    height: 100%;
    min-height: 400px;
    position: relative;
  }

  .neural-sphere-wrapper canvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
    outline: none;
  }
</style>

<script>
  // Dynamic import for Three.js - works in browser
  async function initNeuralSphere(wrapper: HTMLElement) {
    if (!wrapper) return;

    const THREE = await import('three');

    const scene = new THREE.Scene();

    // Camera setup
    const aspect = wrapper.clientWidth / wrapper.clientHeight;
    const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
    camera.position.z = 5;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true,
    });
    renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    wrapper.appendChild(renderer.domElement);

    // Create neural network sphere
    const sphere = new THREE.Group();
    const nodes: THREE.Mesh[] = [];
    const lines: THREE.Line[] = [];

    // Create nodes on sphere surface
    const nodeCount = 80;
    const radius = 2;
    const positions: THREE.Vector3[] = [];

    // Fibonacci sphere algorithm for even distribution
    const phi = Math.PI * (3 - Math.sqrt(5));

    for (let i = 0; i < nodeCount; i++) {
      const y = 1 - (i / (nodeCount - 1)) * 2;
      const radiusAtY = Math.sqrt(1 - y * y);
      const theta = phi * i;

      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;

      const position = new THREE.Vector3(x * radius, y * radius, z * radius);
      positions.push(position);

      // Create glowing node
      const nodeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
      const nodeMaterial = new THREE.MeshBasicMaterial({
        color: 0x0d9488,
        transparent: true,
        opacity: 0.9,
      });
      const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
      node.position.copy(position);
      sphere.add(node);
      nodes.push(node);
    }

    // Create connections between nearby nodes
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x0d9488,
      transparent: true,
      opacity: 0.15,
    });

    for (let i = 0; i < positions.length; i++) {
      for (let j = i + 1; j < positions.length; j++) {
        const distance = positions[i].distanceTo(positions[j]);
        if (distance < 1.2) {
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([
            positions[i],
            positions[j],
          ]);
          const line = new THREE.Line(lineGeometry, lineMaterial.clone());
          sphere.add(line);
          lines.push(line);
        }
      }
    }

    // Add outer ring particles
    const ringGeometry = new THREE.BufferGeometry();
    const ringPositions = new Float32Array(300 * 3);

    for (let i = 0; i < 300; i++) {
      const theta = (i / 300) * Math.PI * 2;
      const ringRadius = 2.8 + Math.random() * 0.5;
      ringPositions[i * 3] = Math.cos(theta) * ringRadius;
      ringPositions[i * 3 + 1] = (Math.random() - 0.5) * 2;
      ringPositions[i * 3 + 2] = Math.sin(theta) * ringRadius;
    }

    ringGeometry.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));

    const ringMaterial = new THREE.PointsMaterial({
      color: 0x1e40af,
      size: 0.03,
      transparent: true,
      opacity: 0.6,
    });

    const ring = new THREE.Points(ringGeometry, ringMaterial);
    sphere.add(ring);

    scene.add(sphere);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const pointLight = new THREE.PointLight(0x0d9488, 2, 100);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    const pointLight2 = new THREE.PointLight(0x1e40af, 2, 100);
    pointLight2.position.set(-5, -5, 5);
    scene.add(pointLight2);

    // Mouse interaction
    let mouseX = 0;
    let mouseY = 0;

    const onMouseMove = (event: MouseEvent) => {
      const rect = wrapper.getBoundingClientRect();
      mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    };

    const onWindowResize = () => {
      const aspect = wrapper.clientWidth / wrapper.clientHeight;
      camera.aspect = aspect;
      camera.updateProjectionMatrix();
      renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
    };

    wrapper.addEventListener('mousemove', onMouseMove);
    window.addEventListener('resize', onWindowResize);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Auto rotation
      sphere.rotation.y += 0.003;
      sphere.rotation.x += 0.001;

      // Mouse interaction
      sphere.rotation.y += mouseX * 0.02;
      sphere.rotation.x += mouseY * 0.02;

      // Animate nodes
      const time = Date.now() * 0.001;
      nodes.forEach((node, i) => {
        const scale = 1 + Math.sin(time + i * 0.5) * 0.3;
        node.scale.setScalar(scale);
      });

      // Animate line opacity
      lines.forEach((line, i) => {
        const material = line.material as THREE.LineBasicMaterial;
        material.opacity = 0.1 + Math.sin(time + i * 0.2) * 0.08;
      });

      renderer.render(scene, camera);
    }

    animate();
  }

  // Initialize all sphere wrappers on the page
  document.querySelectorAll('.neural-sphere-wrapper').forEach((wrapper) => {
    initNeuralSphere(wrapper as HTMLElement);
  });
</script>
